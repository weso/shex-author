{"ast":null,"code":"\"use strict\";\n\nvar CodeMirror = require(\"codemirror\");\n\nvar $ = require('jquery');\n\nCodeMirror.defineMode(\"shex\", function (config, parserConfig) {\n  // var indentUnit = config.indentUnit;\n  var grammar = require(\"./_tokenizer-table.js\");\n\n  var ll1_table = grammar.table;\n  var IRI_REF = '<[^<>\"`\\|\\{\\}\\^\\\\\\x00-\\x20]*>'; //var RDF_TYPE = 'a';\n\n  /*\n  * PN_CHARS_BASE =\n  * '[A-Z]|[a-z]|[\\\\u00C0-\\\\u00D6]|[\\\\u00D8-\\\\u00F6]|[\\\\u00F8-\\\\u02FF]|[\\\\u0370-\\\\u037D]|[\\\\u037F-\\\\u1FFF]|[\\\\u200C-\\\\u200D]|[\\\\u2070-\\\\u218F]|[\\\\u2C00-\\\\u2FEF]|[\\\\u3001-\\\\uD7FF]|[\\\\uF900-\\\\uFDCF]|[\\\\uFDF0-\\\\uFFFD]|[\\\\u10000-\\\\uEFFFF]';\n  */\n\n  var PN_CHARS_BASE = \"[A-Za-z\\\\u00C0-\\\\u00D6\\\\u00D8-\\\\u00F6\\\\u00F8-\\\\u02FF\\\\u0370-\\\\u037D\\\\u037F-\\\\u1FFF\\\\u200C-\\\\u200D\\\\u2070-\\\\u218F\\\\u2C00-\\\\u2FEF\\\\u3001-\\\\uD7FF\\\\uF900-\\\\uFDCF\\\\uFDF0-\\\\uFFFD]\";\n  var PN_CHARS_U = PN_CHARS_BASE + \"|_\";\n  var PN_CHARS = \"(\" + PN_CHARS_U + \"|-|[0-9\\\\u00B7\\\\u0300-\\\\u036F\\\\u203F-\\\\u2040])\";\n  /*\n  var VARNAME = \"(\" + PN_CHARS_U + \"|[0-9])\" + \"(\" + PN_CHARS_U + \"|[0-9\\\\u00B7\\\\u0300-\\\\u036F\\\\u203F-\\\\u2040])*\";\n   var VAR1 = \"\\\\?\" + VARNAME;\n  var VAR2 = \"\\\\$\" + VARNAME;\n  */\n\n  var OR = \"OR\";\n  var AND = \"AND\";\n  var NOT = \"NOT\";\n  var PN_PREFIX = \"(\" + PN_CHARS_BASE + \")(((\" + PN_CHARS + \")|\\\\.)*(\" + PN_CHARS + \"))?\";\n  var HEX = \"[0-9A-Fa-f]\";\n  var PERCENT = \"(%\" + HEX + HEX + \")\";\n  var PN_LOCAL_ESC = \"(\\\\\\\\[_~\\\\.\\\\-!\\\\$&'\\\\(\\\\)\\\\*\\\\+,;=/\\\\?#@%])\";\n  var PLX = \"(\" + PERCENT + \"|\" + PN_LOCAL_ESC + \")\";\n  var PN_LOCAL = \"(\" + PN_CHARS_U + \"|:|[0-9]|\" + PLX + \")((\" + PN_CHARS + \"|\\\\.|:|\" + PLX + \")*(\" + PN_CHARS + \"|:|\" + PLX + \"))?\";\n  var BLANK_NODE_LABEL = \"_:(\" + PN_CHARS_U + \"|[0-9])((\" + PN_CHARS + \"|\\\\.)*\" + PN_CHARS + \")?\";\n  var PNAME_NS = \"(\" + PN_PREFIX + \")?:\";\n  var PNAME_LN = PNAME_NS + PN_LOCAL; // var ATPNAME_NS = \"@[a-zA-Z]*:\";\n\n  var ATPNAME_LN = \"@\" + PNAME_LN + '|' + \"@\" + IRI_REF + '|' + \"@\" + BLANK_NODE_LABEL;\n  var LANGTAG = \"@[a-zA-Z]+(-[a-zA-Z0-9]+)*\";\n  var EXPONENT = \"[eE][\\\\+-]?[0-9]+\";\n  var INTEGER = \"[0-9]+\";\n  var DECIMAL = \"(([0-9]+\\\\.[0-9]*)|(\\\\.[0-9]+))\";\n  var DOUBLE = \"(([0-9]+\\\\.[0-9]*\" + EXPONENT + \")|\" + \"(\\\\.[0-9]+\" + EXPONENT + \")|\" + \"([0-9]+\" + EXPONENT + \"))\";\n  var ECHAR = \"\\\\\\\\[tbnrf\\\\\\\\\\\"']\";\n  var REPEAT_RANGE = \"{\" + INTEGER + \"(\\\\,(\" + INTEGER + \"|\\\\*)?)?}\";\n  var UCHAR = \"\\\\u \" + HEX + HEX + HEX + HEX + \"| \\\\U \" + HEX + HEX + HEX + HEX + HEX + HEX + HEX + HEX;\n  var CODE = \"{ ([^%\\\\\\\\] | \\\\\\\\ [%\\\\\\\\] | \" + UCHAR + \")*%}\";\n  var REGEXP = \"\\\\~\\\\/ ([^\\\\x2f\\\\x5C\\\\xA\\\\xD] | \\\\\\\\ [tbnrf\\\\\\\\/] | \" + UCHAR + \")* \\\\/ [smix]*\"; //IMPORTANT: this unicode rule is not in the official grammar.\n  //Reason: https://github.com/YASGUI/YASQE/issues/49\n  //unicode escape sequences (which the sparql spec considers part of the pre-processing of sparql queries)\n  //are marked as invalid. We have little choice (other than adding a layer of complixity) than to modify the grammar accordingly\n  //however, for now only allow these escape sequences in literals (where actually, this should be allows in e.g. prefixes as well)\n\n  var hex4 = HEX + \"{4}\";\n  var unicode = \"(\\\\\\\\u\" + hex4 + \"|\\\\\\\\U00(10|0\" + HEX + \")\" + hex4 + \")\";\n  var LINE_BREAK = \"\\n\";\n  var STRING_LITERAL1 = \"'(([^\\\\x27\\\\x5C\\\\x0A\\\\x0D])|\" + ECHAR + \"|\" + unicode + \")*'\";\n  var STRING_LITERAL2 = '\"(([^\\\\x22\\\\x5C\\\\x0A\\\\x0D])|' + ECHAR + \"|\" + unicode + ')*\"';\n  var STRING_LITERAL_LONG = {\n    SINGLE: {\n      CAT: \"STRING_LITERAL_LONG1\",\n      QUOTES: \"'''\",\n      CONTENTS: \"(('|'')?([^'\\\\\\\\]|\" + ECHAR + \"|\" + unicode + \"))*\"\n    },\n    DOUBLE: {\n      CAT: \"STRING_LITERAL_LONG2\",\n      QUOTES: '\"\"\"',\n      CONTENTS: '((\"|\"\")?([^\"\\\\\\\\]|' + ECHAR + \"|\" + unicode + \"))*\"\n    }\n  };\n\n  for (var key in STRING_LITERAL_LONG) {\n    STRING_LITERAL_LONG[key].COMPLETE = STRING_LITERAL_LONG[key].QUOTES + STRING_LITERAL_LONG[key].CONTENTS + STRING_LITERAL_LONG[key].QUOTES;\n  } //\tvar STRING_LITERAL_LONG_QUOTES = {\n  //\t\t\"STRING_LITERAL_LONG_QUOTES1\": \"'''\",\n  //\t\t\"STRING_LITERAL_LONG_QUOTES2\": '\"\"\"',\n  //\t}\n  //\tvar STRING_LITERAL_LONG_CONTENTS = {\n  //\t\t\"STRING_LITERAL_LONG_QUOTES1\": \"(('|'')?([^'\\\\\\\\]|\"+ECHAR+\"|\"+unicode+\"))*\",\n  //\t\t\"STRING_LITERAL_LONG_QUOTES2\": '((\"|\"\")?([^\"\\\\\\\\]|'+ECHAR+'|'+unicode+'))*'\n  //\t};\n  //\tvar STRING_LITERAL_LONG1 = STRING_LITERAL_LONG['SINGLE'].QUOTES + STRING_LITERAL_LONG['SINGLE'].CONTENTS + STRING_LITERAL_LONG['SINGLE'].QUOTES;\n  //\tvar STRING_LITERAL_LONG2 = STRING_LITERAL_LONG['DOUBLE'].QUOTES + STRING_LITERAL_LONG['DOUBLE'].CONTENTS + STRING_LITERAL_LONG['DOUBLE'].QUOTES;\n  //\tvar stringLiteralLongContentTerminals = {};\n  //\tfor (var key in STRING_LITERAL_LONG) {\n  //\t\tstringLiteralLongContentTerminals[key] = {\n  //\t\t\tname: key,\n  //\t\t\tregex:new RegExp(\"^\"+STRING_LITERAL_LONG_CONTENTS[key]),\n  //\t\t\tstyle:\"string\"\n  //\t\t};\n  //\t}\n  //some regular expressions not used in regular terminals, because this is used accross lines\n\n\n  var stringLiteralLongRegex = {};\n\n  for (var key in STRING_LITERAL_LONG) {\n    stringLiteralLongRegex[key] = {\n      complete: {\n        name: \"STRING_LITERAL_LONG_\" + key,\n        regex: new RegExp(\"^\" + STRING_LITERAL_LONG[key].COMPLETE),\n        style: \"string\"\n      },\n      contents: {\n        name: \"STRING_LITERAL_LONG_\" + key,\n        regex: new RegExp(\"^\" + STRING_LITERAL_LONG[key].CONTENTS),\n        style: \"string\"\n      },\n      closing: {\n        name: \"STRING_LITERAL_LONG_\" + key,\n        regex: new RegExp(\"^\" + STRING_LITERAL_LONG[key].CONTENTS + STRING_LITERAL_LONG[key].QUOTES),\n        style: \"string\"\n      },\n      quotes: {\n        name: \"STRING_LITERAL_LONG_QUOTES_\" + key,\n        regex: new RegExp(\"^\" + STRING_LITERAL_LONG[key].QUOTES),\n        style: \"string\"\n      }\n    };\n  }\n\n  var WS = \"[\\\\x20\\\\x09\\\\x0D\\\\x0A]\"; // Careful! Code mirror feeds one line at a time with no \\n\n  // ... but otherwise comment is terminated by \\n\n\n  var COMMENT = \"#([^\\\\n\\\\r]*[\\\\n\\\\r]|[^\\\\n\\\\r]*$)\"; //var WS_OR_COMMENT_STAR = \"(\" + WS + \"|(\" + COMMENT + \"))*\";\n  //var NIL = \"\\\\(\" + WS_OR_COMMENT_STAR + \"\\\\)\";\n  //var ANON = \"\\\\[\" + WS_OR_COMMENT_STAR + \"\\\\]\";\n\n  var terminals = [{\n    name: \"WS\",\n    regex: new RegExp(\"^\" + WS + \"+\"),\n    style: \"ws\"\n  }, {\n    name: \"COMMENT\",\n    regex: new RegExp(\"^\" + COMMENT),\n    style: \"comment\"\n  }, {\n    name: \"OR\",\n    regex: new RegExp(\"^\" + OR),\n    style: \"logical\"\n  }, {\n    name: \"AND\",\n    regex: new RegExp(\"^\" + AND),\n    style: \"logical\"\n  }, {\n    name: \"NOT\",\n    regex: new RegExp(\"^\" + NOT),\n    style: \"logical\"\n  }, {\n    name: \"IRI_REF\",\n    regex: new RegExp(\"^\" + IRI_REF),\n    style: \"variable-3\"\n  }, {\n    name: \"DOUBLE\",\n    regex: new RegExp(\"^\" + DOUBLE),\n    style: \"number\"\n  }, {\n    name: \"DECIMAL\",\n    regex: new RegExp(\"^\" + DECIMAL),\n    style: \"number\"\n  }, {\n    name: \"INTEGER\",\n    regex: new RegExp(\"^\" + INTEGER),\n    style: \"number\"\n  }, {\n    name: \"STRING_LITERAL1\",\n    regex: new RegExp(\"^\" + STRING_LITERAL1),\n    style: \"string\"\n  }, {\n    name: \"STRING_LITERAL2\",\n    regex: new RegExp(\"^\" + STRING_LITERAL2),\n    style: \"string\"\n  }, {\n    name: \"PNAME_LN\",\n    regex: new RegExp(\"^\" + PNAME_LN),\n    style: \"string-2\"\n  }, {\n    name: \"PNAME_NS\",\n    regex: new RegExp(\"^\" + PNAME_NS),\n    style: \"string-2\"\n  }, {\n    name: \"BLANK_NODE_LABEL\",\n    regex: new RegExp(\"^\" + BLANK_NODE_LABEL),\n    style: \"string-2\"\n  }, {\n    name: \"ATPNAME_LN\",\n    regex: new RegExp(\"^\" + ATPNAME_LN),\n    style: \"at\"\n  }, {\n    name: \"REPEAT_RANGE\",\n    regex: new RegExp(\"^\" + REPEAT_RANGE),\n    style: \"at\"\n  }, {\n    name: \"REPEAT_RANGE\",\n    regex: new RegExp(\"^\" + REPEAT_RANGE),\n    style: \"at\"\n  }, {\n    name: \"UCHAR\",\n    regex: new RegExp(\"^\" + UCHAR),\n    style: \"at\"\n  }, {\n    name: \"CODE\",\n    regex: new RegExp(\"^\" + CODE),\n    style: \"at\"\n  }, {\n    name: \"REGEXP\",\n    regex: new RegExp(\"^\" + REGEXP),\n    style: \"at\"\n  }, {\n    name: \"LANGTAG\",\n    regex: new RegExp(\"^\" + LANGTAG),\n    style: \"at\"\n  }];\n\n  function getPossibles(symbol) {\n    var possibles = [],\n        possiblesOb = ll1_table[symbol];\n\n    if (possiblesOb != undefined) {\n      for (var property in possiblesOb) {\n        possibles.push(property.toString());\n      }\n    } else {\n      possibles.push(symbol);\n    }\n\n    return possibles;\n  }\n\n  function tokenBase(stream, state) {\n    function nextToken() {\n      var consumed = null;\n\n      if (state.inLiteral) {\n        var closingQuotes = false; //multi-line literal. try to parse contents.\n\n        consumed = stream.match(stringLiteralLongRegex[state.inLiteral].contents.regex, true, false);\n\n        if (consumed && consumed[0].length == 0) {\n          //try seeing whether we can consume closing quotes, to avoid stopping\n          consumed = stream.match(stringLiteralLongRegex[state.inLiteral].closing.regex, true, false);\n          closingQuotes = true;\n        }\n\n        if (consumed && consumed[0].length > 0) {\n          //some string content here.\n          var returnObj = {\n            quotePos: closingQuotes ? \"end\" : \"content\",\n            cat: STRING_LITERAL_LONG[state.inLiteral].CAT,\n            style: stringLiteralLongRegex[state.inLiteral].complete.style,\n            text: consumed[0],\n            start: stream.start\n          };\n          if (closingQuotes) state.inLiteral = false;\n          return returnObj;\n        }\n      } //Multiline literals\n\n\n      for (var quoteType in stringLiteralLongRegex) {\n        consumed = stream.match(stringLiteralLongRegex[quoteType].quotes.regex, true, false);\n\n        if (consumed) {\n          var quotePos;\n\n          if (state.inLiteral) {\n            //end of literal. everything is fine\n            state.inLiteral = false;\n            quotePos = \"end\";\n          } else {\n            state.inLiteral = quoteType;\n            quotePos = \"start\";\n          }\n\n          return {\n            cat: STRING_LITERAL_LONG[quoteType].CAT,\n            style: stringLiteralLongRegex[quoteType].quotes.style,\n            text: consumed[0],\n            quotePos: quotePos,\n            start: stream.start\n          };\n        }\n      } // Tokens defined by individual regular expressions\n\n\n      for (var i = 0; i < terminals.length; ++i) {\n        consumed = stream.match(terminals[i].regex, true, false);\n\n        if (consumed) {\n          var lastPos = $.trim(stream.string).length - 1;\n          var lastToken = $.trim(stream.string)[lastPos];\n\n          var _token = stream.current(); //Is a shapeExprLabel?\n\n\n          if (lastToken == '{' && (_token.includes(':') || _token.includes('<'))) {\n            return {\n              cat: terminals[i].name,\n              style: 'shape',\n              text: consumed[0],\n              start: stream.start\n            };\n          }\n\n          return {\n            cat: terminals[i].name,\n            style: terminals[i].style,\n            text: consumed[0],\n            start: stream.start\n          };\n        }\n      } // Keywords\n\n\n      consumed = stream.match(grammar.keywords, true, false);\n\n      if (consumed) {\n        return {\n          cat: stream.current().toUpperCase(),\n          style: \"keyword\",\n          text: consumed[0],\n          start: stream.start\n        };\n      } // Punctuation\n\n\n      consumed = stream.match(grammar.punct, true, false);\n\n      if (consumed) {\n        if (stream.current() != '*' && stream.current() != '+' && stream.current() != '?') {\n          return {\n            cat: stream.current(),\n            style: \"punc\",\n            text: consumed[0],\n            start: stream.start\n          };\n        }\n\n        return {\n          cat: stream.current(),\n          style: \"card\",\n          text: consumed[0],\n          start: stream.start\n        };\n      } // Token is invalid\n      // better consume something anyway, or else we're stuck\n\n\n      consumed = stream.match(/^.[A-Za-z0-9]*/, true, false);\n      return {\n        cat: \"<invalid_token>\",\n        style: \"error\",\n        text: consumed[0],\n        start: stream.start\n      };\n    }\n\n    function recordFailurePos() {\n      // tokenOb.style= \"sp-invalid\";\n      var col = stream.column();\n      state.errorStartPos = col;\n      state.errorEndPos = col + tokenOb.text.length;\n    } // Some fake non-terminals are just there to have side-effect on state\n    // - i.e. allow or disallow variables and bnodes in certain non-nesting\n    // contexts\n\n\n    function setSideConditions(topSymbol) {\n      if (topSymbol === \"prefixDecl\") {\n        state.inPrefixDecl = true;\n      } else {\n        state.inPrefixDecl = false;\n      }\n\n      switch (topSymbol) {\n        case \"disallowVars\":\n          state.allowVars = false;\n          break;\n\n        case \"allowVars\":\n          state.allowVars = true;\n          break;\n\n        case \"disallowBnodes\":\n          state.allowBnodes = false;\n          break;\n\n        case \"allowBnodes\":\n          state.allowBnodes = true;\n          break;\n\n        case \"storeProperty\":\n          state.storeProperty = true;\n          break;\n      }\n    }\n\n    function checkSideConditions(topSymbol) {\n      return (state.allowVars || topSymbol != \"var\") && (state.allowBnodes || topSymbol != \"blankNode\" && topSymbol != \"blankNodePropertyList\" && topSymbol != \"blankNodePropertyListPath\");\n    } // CodeMirror works with one line at a time,\n    // but newline should behave like whitespace\n    // - i.e. a definite break between tokens (for autocompleter)\n\n\n    if (stream.pos == 0) state.possibleCurrent = state.possibleNext;\n    var tokenOb = nextToken();\n\n    if (tokenOb.cat == \"<invalid_token>\") {\n      // set error state, and\n      if (state.OK == true) {\n        state.OK = false;\n        recordFailurePos();\n      }\n\n      state.complete = false; // alert(\"Invalid:\"+tokenOb.text);\n\n      return tokenOb.style;\n    }\n\n    if (tokenOb.cat == \"WS\" || tokenOb.cat == \"COMMENT\" || tokenOb.quotePos && tokenOb.quotePos != \"end\") {\n      state.possibleCurrent = state.possibleNext;\n      return tokenOb.style;\n    } // Otherwise, run the parser until the token is digested\n    // or failure\n\n\n    var finished = false;\n    var topSymbol;\n    var token = tokenOb.cat;\n\n    if (!tokenOb.quotePos || tokenOb.quotePos == \"end\") {\n      // Incremental LL1 parse\n      while (state.stack.length > 0 && token && state.OK && !finished) {\n        topSymbol = state.stack.pop();\n        if (topSymbol === 'var' && tokenOb.text) state.variables[tokenOb.text] = tokenOb.text;\n\n        if (!ll1_table[topSymbol]) {\n          // Top symbol is a terminal\n          if (topSymbol == token) {\n            if (state.inPrefixDecl) {\n              if (topSymbol === \"PNAME_NS\" && tokenOb.text.length > 0) {\n                state.currentPnameNs = tokenOb.text.slice(0, -1);\n              } else if (state.currentPnameNs !== undefined && tokenOb.text.length > 2) {\n                state.prefixes[state.currentPnameNs] = tokenOb.text.slice(1, -1); //reset current pname ns\n\n                state.currentPnameNs = undefined;\n              }\n            } // Matching terminals\n            // - consume token from input stream\n\n\n            finished = true; //setQueryType(topSymbol);\n            // Check whether $ (end of input token) is poss next\n            // for everything on stack\n\n            var allNillable = true;\n\n            for (var sp = state.stack.length; sp > 0; --sp) {\n              var item = ll1_table[state.stack[sp - 1]];\n              if (!item || !item[\"$\"]) allNillable = false;\n            }\n\n            state.complete = allNillable;\n\n            if (state.storeProperty && token.cat != \"punc\") {\n              state.lastProperty = tokenOb.text;\n              state.storeProperty = false;\n            } //check whether a used prefix is actually defined\n\n\n            if (!state.inPrefixDecl && (token === \"PNAME_NS\" || token === \"PNAME_LN\")) {\n              var colonIndex = tokenOb.text.indexOf(\":\");\n\n              if (colonIndex >= 0) {\n                var prefNs = tokenOb.text.slice(0, colonIndex); //avoid warnings for missing bif prefixes (yuck, virtuoso-specific)\n\n                if (!state.prefixes[prefNs] && [\"bif\", \"xsd\", \"sql\"].indexOf(prefNs) < 0) {\n                  state.OK = false;\n                  recordFailurePos();\n                  state.errorMsg = \"Prefix '\" + prefNs + \"' is not defined\";\n                }\n              }\n            }\n          } else {\n            state.OK = false;\n            state.complete = false;\n            recordFailurePos();\n          }\n        } else {\n          // topSymbol is nonterminal\n          // - see if there is an entry for topSymbol\n          // and nextToken in table\n          var nextSymbols = ll1_table[topSymbol][token];\n\n          if (nextSymbols != undefined && checkSideConditions(topSymbol)) {\n            // Match - copy RHS of rule to stack\n            for (var i = nextSymbols.length - 1; i >= 0; --i) {\n              state.stack.push(nextSymbols[i]);\n            } // Peform any non-grammatical side-effects\n\n\n            setSideConditions(topSymbol);\n          } else {\n            // No match in table - fail\n            state.OK = false;\n            state.complete = false;\n            recordFailurePos();\n            state.stack.push(topSymbol); // Shove topSymbol back on stack\n          }\n        }\n      }\n    }\n\n    if (!finished && state.OK) {\n      state.OK = false;\n      state.complete = false;\n      recordFailurePos();\n    }\n\n    if (state.possibleCurrent.indexOf(\"a\") >= 0) {\n      state.lastPredicateOffset = tokenOb.start;\n    }\n\n    state.possibleCurrent = state.possibleNext;\n    state.possibleNext = getPossibles(state.stack[state.stack.length - 1]);\n    return tokenOb.style;\n  }\n\n  var indentTop = {\n    \"*[,, object]\": 3,\n    \"*[(,),object]\": 3,\n    \"*[(,),objectPath]\": 3,\n    \"*[/,pathEltOrInverse]\": 2,\n    object: 2,\n    objectPath: 2,\n    objectList: 2,\n    objectListPath: 2,\n    storeProperty: 2,\n    pathMod: 2,\n    \"?pathMod\": 2,\n    propertyListNotEmpty: 1,\n    propertyList: 1,\n    propertyListPath: 1,\n    propertyListPathNotEmpty: 1,\n    \"?[verb,objectList]\": 1 //\t\t\"?[or([verbPath, verbSimple]),objectList]\": 1,\n\n  };\n  var indentTable = {\n    \"}\": 1,\n    \"]\": 1,\n    \")\": 1,\n    \"{\": -1,\n    \"(\": -1,\n    \"[\": -1 //\t\t\"*[;,?[or([verbPath,verbSimple]),objectList]]\": 1,\n\n  };\n\n  function indent(state, textAfter) {\n    //just avoid we don't indent multi-line  literals\n    if (state.inLiteral) return 0;\n\n    if (state.stack.length && state.stack[state.stack.length - 1] == \"?[or([verbPath,verbSimple]),objectList]\") {\n      //we are after a semi-colon. I.e., nicely align this line with predicate position of previous line\n      return state.lastPredicateOffset;\n    } else {\n      var n = 0; // indent level\n\n      var i = state.stack.length - 1;\n\n      if (/^[\\}\\]\\)]/.test(textAfter)) {\n        // Skip stack items until after matching bracket\n        var closeBracket = textAfter.substr(0, 1);\n\n        for (; i >= 0; --i) {\n          if (state.stack[i] == closeBracket) {\n            --i;\n            break;\n          }\n        }\n      } else {\n        // Consider nullable non-terminals if at top of stack\n        var dn = indentTop[state.stack[i]];\n\n        if (dn) {\n          n += dn;\n          --i;\n        }\n      }\n\n      for (; i >= 0; --i) {\n        var dn = indentTable[state.stack[i]];\n\n        if (dn) {\n          n += dn;\n        }\n      }\n\n      return n * config.indentUnit;\n    }\n  }\n\n  return {\n    token: tokenBase,\n    startState: function startState(base) {\n      return {\n        tokenize: tokenBase,\n        OK: true,\n        complete: grammar.acceptEmpty,\n        errorStartPos: null,\n        errorEndPos: null,\n        queryType: null,\n        possibleCurrent: getPossibles(grammar.startSymbol),\n        possibleNext: getPossibles(grammar.startSymbol),\n        allowVars: true,\n        allowBnodes: true,\n        storeProperty: false,\n        lastProperty: \"\",\n        inLiteral: false,\n        stack: [grammar.startSymbol],\n        lastPredicateOffset: config.indentUnit,\n        prefixes: {},\n        variables: {}\n      };\n    },\n    indent: indent,\n    electricChars: \"}])\"\n  };\n});\nCodeMirror.defineMIME(\"application/x-shex\", \"shex\");","map":null,"metadata":{},"sourceType":"script"}