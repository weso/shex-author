{"ast":null,"code":"'use strict'; // make sure any console statements\n\nwindow.console = window.console || {\n  log: function log() {}\n};\n/**\n * Load libraries and utils\n */\n\nvar $ = require('jquery');\n\nvar codeMirror = require('codemirror');\n\nvar utils = require('./utils/baseUtils.js');\n\nvar yutils = require('yasgui-utils');\n\nvar prefixUtils = require('./utils/prefixUtils.js');\n\nvar tokenUtils = require('./utils/tokenUtils.js');\n\nvar syntaxUtils = require('./utils/syntaxUtils.js');\n\nvar tooltipUtils = require('./utils/tooltipUtils.js');\n\nvar formatUtils = require('./utils/formatUtils.js');\n\nvar buttonsUtils = require('./utils/buttonsUtils.js');\n\nvar prefixFold = require('./utils/prefixFold.js');\n\nvar autocompletersBase = require('./autocompleters/autocompleterBase.js');\n\nvar Clipboard = require('clipboard');\n\nrequire('../lib/deparam.js');\n\nrequire('codemirror/addon/fold/foldcode.js');\n\nrequire('codemirror/addon/fold/foldgutter.js');\n\nrequire('codemirror/addon/fold/xml-fold.js');\n\nrequire('codemirror/addon/fold/brace-fold.js');\n\nrequire('codemirror/addon/hint/show-hint.js');\n\nrequire('codemirror/addon/search/searchcursor.js');\n\nrequire('codemirror/addon/edit/matchbrackets.js');\n\nrequire('codemirror/addon/runmode/runmode.js');\n\nrequire('codemirror/addon/display/fullscreen.js');\n\nrequire('../lib/grammar/tokenizer.js');\n/**\n * Main YASHE constructor.\n * Pass a DOM element as argument to append the editor to,\n * and (optionally) pass along config settings\n * (see the YASHE.defaults object below,\n * as well as the regular codeMirror documentation,\n * for more information on configurability)\n *\n * @constructor\n * @param {DOM-Element} parent element to append editor to.\n * @param {object} config\n * @class YASHE\n * @return {doc} YASHE document\n */\n\n\nvar root = module.exports = function (parent, config) {\n  var rootEl = $('<div>', {\n    class: 'yashe'\n  }).appendTo($(parent));\n  config = extendConfig(config);\n  var yashe = extendCmInstance(codeMirror(rootEl[0], config));\n  postProcessCmElement(yashe);\n  return yashe;\n};\n/**\n * Extend config object, which we will pass on to the CM constructor later on.\n * Need this, to make sure our own 'onBlur' etc events do not get overwritten by\n * people who add their own onblur events to the config Additionally, need this\n * to include the CM defaults ourselves. codeMirror has a method for including\n * defaults, but we can't rely on that one: it assumes flat config object, where\n * we have nested objects (e.g. the persistency option)\n *\n * @private\n * @param {object} config\n * @return {object} YASHE config\n */\n\n\nvar extendConfig = function extendConfig(config) {\n  var extendedConfig = $.extend(true, {}, root.defaults, config); // I know, codemirror deals with  default options as well.\n  // However, it does not do this recursively (i.e. the persistency option)\n\n  return extendedConfig;\n};\n/**\n * Add extra functions to the CM document (i.e. the codemirror instantiated\n * object)\n *\n * @private\n * @param {object} yashe\n * @return {doc} YASHE document\n */\n\n\nvar extendCmInstance = function extendCmInstance(yashe) {\n  // instantiate autocompleters\n  yashe.autocompleters = autocompletersBase(root, yashe);\n\n  if (yashe.options.autocompleters) {\n    yashe.options.autocompleters.forEach(function (name) {\n      if (root.Autocompleters[name]) {\n        yashe.autocompleters.init(name, root.Autocompleters[name]);\n      }\n    });\n  }\n  /**\n   * Returns the entire token by the cursor\n   * @return {object} token\n  */\n\n\n  yashe.getCompleteToken = function () {\n    return tokenUtils.getCompleteToken(yashe);\n  };\n  /**\n   * Returns the previous token that is not a WS token\n   * @param {onject} line\n   * @param {onject} token\n   * @return {object} token\n  */\n\n\n  yashe.getPreviousNonWsToken = function (line, token) {\n    return tokenUtils.getPreviousNonWsToken(yashe, line, token);\n  };\n  /**\n   * Returns the next token that is not a WS token\n   * @param {onject} lineNumber\n   * @param {onject} charNumber\n   * @return {object} token\n  */\n\n\n  yashe.getNextNonWsToken = function (lineNumber, charNumber) {\n    return tokenUtils.getNextNonWsToken(yashe, lineNumber, charNumber);\n  };\n  /**\n   * Colapse all prefixes of the ShEx documment\n   * @param {boolean} collapse\n  */\n\n\n  yashe.collapsePrefixes = function (collapse) {\n    if (collapse === undefined) collapse = true;\n    yashe.foldCode();\n  };\n  /**\n   * Returns true if yashe has syntax errors. False otherwise\n   * @param {object} yashe\n   * @return {boolean} \n   */\n\n\n  yashe.hasErrors = function () {\n    return !syntaxUtils.checkSyntax(yashe);\n  };\n  /**\n   * Fetch defined prefixes\n   * @method doc.getDefinedPrefixes\n   * @return {object} prefixes\n   */\n\n\n  yashe.getDefinedPrefixes = function () {\n    return prefixUtils.getDefinedPrefixes(yashe);\n  };\n  /**\n   * Add prefixes to the ShEx documment\n   * @param {string|list} prefixes String if you want to add just one\n   * List in other case\n   */\n\n\n  yashe.addPrefixes = function (prefixes) {\n    prefixUtils.addPrefixes(yashe, prefixes);\n  };\n  /**\n   * Remove prefixes from the ShEx documment\n   * @param {list} prefixes\n   */\n\n\n  yashe.removePrefixes = function (prefixes) {\n    prefixUtils.removePrefixes(yashe, prefixes);\n  };\n  /**\n   * Allows to enable or disable Systax error checker\n   * @param {boolean} isEnabled\n   */\n\n\n  yashe.setCheckSyntaxErrors = function (isEnabled) {\n    yashe.options.syntaxErrorCheck = isEnabled;\n    checkSyntax(yashe);\n  };\n  /**\n   * Enables the autocompleter that you pass by param\n   * @param {string} name The name of the autocompleter\n   */\n\n\n  yashe.enableCompleter = function (name) {\n    addCompleterToSettings(yashe.options, name);\n\n    if (root.Autocompleters[name]) {\n      yashe.autocompleters.init(name, root.Autocompleters[name]);\n    }\n  };\n  /**\n   * Disables the autocompleter that you pass by param\n   * @param {string} name The name of the autocompleter\n   */\n\n\n  yashe.disableCompleter = function (name) {\n    removeCompleterFromSettings(yashe.options, name);\n  };\n\n  return yashe;\n};\n/**\n * Creates autocompleters list in the settigns if it does not exit\n * Add the autocompleter that you pass by param to the atucompleters settigns.\n * @param {object} settings YASHE settings\n * @param {string} name Autocompleter name\n */\n\n\nvar addCompleterToSettings = function addCompleterToSettings(settings, name) {\n  if (!settings.autocompleters) settings.autocompleters = [];\n  settings.autocompleters.push(name);\n};\n/**\n * Remove the autocompleter that you pass by param from the\n * autocompleters settigns.\n * @param {object} settings YASHE settings\n * @param {string} name Autocompleter name\n */\n\n\nvar removeCompleterFromSettings = function removeCompleterFromSettings(settings, name) {\n  if (typeof settings.autocompleters == 'object') {\n    var index = $.inArray(name, settings.autocompleters);\n\n    if (index >= 0) {\n      settings.autocompleters.splice(index, 1); // just in case. suppose 1 completer is listed twice\n\n      removeCompleterFromSettings(settings, name);\n    }\n  }\n};\n/**\n * Add extra funcionalitys to YASHE\n * @param {object} yashe\n */\n\n\nvar postProcessCmElement = function postProcessCmElement(yashe) {\n  buttonsUtils.drawButtons(yashe); // Trigger of the button with id='copy'\n  // Copies the contents of the editor in the clipboard\n\n  new Clipboard('#copyBtn', {\n    text: function text(trigger) {\n      return yashe.getValue();\n    }\n  });\n  /**\n   * Set doc value if option storeShape is activated\n   */\n\n  var storageId = utils.getPersistencyId(yashe, yashe.options.persistent);\n\n  if (storageId) {\n    var valueFromStorage = yutils.storage.get(storageId);\n    if (valueFromStorage) yashe.setValue(valueFromStorage);\n  } // --- Event handlers ----\n\n  /**\n   * Fires whenever the editor is unfocused.\n   * In this case, YASHE stores it content\n   */\n\n\n  yashe.on('blur', function (yashe) {\n    root.storeContent(yashe);\n  });\n  /**\n   * Fires every time the content of the editor is changed.\n   * In this case, YASHE checks the sintax\n   */\n\n  yashe.on('change', function (yashe) {\n    checkSyntax(yashe);\n  });\n  /**\n   * Fires when the editor is scrolled.\n   * In this case, YASHE removes Wikidata Tooltip\n   */\n\n  yashe.on('scroll', function () {\n    tooltipUtils.removeWikiToolTip();\n  });\n  /**\n   * Wikidata Tooltip Listener\n   */\n\n  root.on(yashe.getWrapperElement(), 'mouseover', tooltipUtils.debounce(function (e) {\n    tooltipUtils.removeWikiToolTip();\n    tooltipUtils.triggerTooltip(yashe, e);\n  }, 300)); // on first load, check as well\n  // (our stored or default query might be incorrect)\n\n  checkSyntax(yashe);\n\n  if (yashe.options.collapsePrefixesOnLoad) {\n    yashe.collapsePrefixes(true);\n  }\n};\n/**\n * Stores YASHE content\n * @param {object} yashe\n */\n\n\nroot.storeContent = function (yashe) {\n  var storageId = utils.getPersistencyId(yashe, yashe.options.persistent);\n\n  if (storageId) {\n    yutils.storage.set(storageId, yashe.getValue(), 'month', yashe.options.onQuotaExceeded);\n  }\n};\n/**\n * Checks YASHE content syntax\n * @param {object} yashe\n * @return {string} Check result\n */\n\n\nvar checkSyntax = function checkSyntax(yashe) {\n  return syntaxUtils.checkSyntax(yashe);\n}; // ---- Static Utils -----\n// first take all codeMirror references and store them in the YASHE object\n\n\n$.extend(root, codeMirror); // add registrar for autocompleters\n\nroot.Autocompleters = {};\n\nroot.registerAutocompleter = function (name, constructor) {\n  root.Autocompleters[name] = constructor;\n  addCompleterToSettings(root.defaults, name);\n};\n\nroot.autoComplete = function (yashe) {\n  // this function gets called when pressing the keyboard shortcut.\n  // I.e., autoShow = false\n  yashe.autocompleters.autoComplete(false);\n}; // include the autocompleters we provide out-of-the-box\n\n\nroot.registerAutocompleter('wikidata', require('./autocompleters/wikidata.js'));\nroot.registerAutocompleter('prefixDefinition', require('./autocompleters/prefixDefinition.js'));\nroot.registerAutocompleter('prefixesAndKeywords', require('./autocompleters/prefixesAndKeywords.js'));\n/**\n * Initialize YASHE from an existing text area (see http://codemirror.net/doc/manual.html#fromTextArea for more info)\n  *\n * @method YASHE.fromTextArea\n * @param {DOM-element} textAreaEl\n * @param {object} config\n * @return {doc} YASHE document\n */\n\nroot.fromTextArea = function (textAreaEl, config) {\n  config = extendConfig(config); // add yashe div as parent (needed for styles to be manageable and scoped).\n  // In this case, I -also- put it as parent el of the text area.\n  // This is wrapped in a div now\n\n  $('<div>', {\n    class: 'yashe'\n  }).insertBefore($(textAreaEl)).append($(textAreaEl));\n  var yashe = extendCmInstance(codeMirror.fromTextArea(textAreaEl, config));\n  postProcessCmElement(yashe);\n  return yashe;\n}; // ---- Format utils -----\n\n/**\n * Comment or uncomment current/selected line(s)\n * @param {object} yashe\n */\n\n\nroot.commentLines = function (yashe) {\n  formatUtils.commentLines(yashe);\n};\n/**\n * Copy line up\n * @param {object} yashe\n */\n\n\nroot.copyLineUp = function (yashe) {\n  formatUtils.copyLineUp(yashe);\n};\n/**\n * Copy line down\n * @param {object} yashe\n */\n\n\nroot.copyLineDown = function (yashe) {\n  formatUtils.copyLineDown(yashe);\n};\n/**\n * Auto-format/indent selected lines\n * @param {object} yashe\n */\n\n\nroot.doAutoFormat = function (yashe) {\n  formatUtils.doAutoFormat(yashe);\n};\n\nrequire('./config/defaults.js');\n\nroot.$ = $;\nroot.version = {\n  'codeMirror': codeMirror.version,\n  'YASHE': require('../package.json').version,\n  'jquery': $.fn.jquery,\n  'yasgui-utils': yutils.version\n};","map":null,"metadata":{},"sourceType":"script"}